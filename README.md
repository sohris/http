# Sohris HTTP

## Summary

Sohris HTTP is built on ReactPHP, allowing the server to handle requests asynchronously. This non-blocking architecture enables improved performance, as multiple requests can be processed simultaneously without waiting for previous ones to complete.


### Execution Workflow

1. **Annotation Parsing:** The framework scans classes and methods for annotations.
2. **Route Registration:** Based on `@Route` annotations, the framework automatically registers the endpoints.
3. **Request Validation:** Before execution, the system verifies:
   - If the request uses the correct HTTP method (`@HttpMethod`).
   - If it contains the required parameters (`@Needed`).
   - If a JWT token is present when required (`@SessionJWT`).
4. **Controller Execution:** If all conditions are met, the function is executed and returns the appropriate response.


## Creating a Route

To generate a new route in the API, it is necessary to understand the annotations available in PHP, which help manage requests.

### Route Example

```php
namespace App\Routes\Template;

use Sohris\Http\Response;
use Sohris\Http\Router\RouterControllers\DRMRouter;
use Sohris\Http\Annotations\SessionJWT;
use Sohris\Http\Annotations\Needed;
use Sohris\Http\Annotations\HttpMethod;
use Sohris\Http\Annotations\Route;

class Teste extends DRMRouter
{
    /**
     * @Route("/template/teste/requisicao_1")
     * @SessionJWT(true)
     * @HttpMethod("POST")
     * @Needed({"param_1", "param_2"})
     */
    public static function requisicao_1(\Psr\Http\Message\RequestInterface $request)
    {        
        return Response::Json("Hello World!");
    }
}
```

## Infrastructure

Each new request within the API can be represented by a new route. To maintain organization, routes are grouped into directories based on their context.

### Example Directory Structure

If we have requests related to users, such as login, logout, and registration information, we can organize them as follows:

```
src/
|-Routes/
|--User/
|---Auth.php (Access control: login and logout)
|---Information.php (Registration information)
```

## Namespaces

Namespaces are used to organize files within the project.

For example, considering the following namespace:

```php
namespace App\Routes\Template;
```

It follows this directory structure:

- `App` -> Root directory `src`
- `Routes` -> `Routes` directory inside `src`
- `Template` -> `Template` subdirectory inside `Routes`

## Annotations and Functionality

The API uses PHP annotations to define route behavior declaratively. Each annotation represents an instruction on how the route should operate.

### `@Route`

Defines the endpoint that will be handled by the function. The route path must follow the hierarchy: `directory -> file -> function`.

#### Example Endpoints

```
src/
|-Routes/
|--Teste/
|---Auth.php
|--Teste1/
|---Teste1.1/
|----Usuario.php
```

If `Auth.php` contains the function `login_google` and `Usuario.php` contains `user_info`, their respective endpoints will be:

```
/teste/auth/login_google
/teste1/teste1.1/usuario/user_info
```

**Important:** Routes must be created in **lowercase** to maintain project standards.

### `@Needed`

Defines the required parameters in the request.

```php
@Needed({"param_1", "param_2"})
```

The parameters can be accessed via `REQUEST` in the request object:

```php
public static function rota_1(\Psr\Http\Message\RequestInterface $request)
{
    echo $request->REQUEST['param_1'];
    echo $request->REQUEST['param_2'];
}
```

### `@SessionJWT`

Indicates that the route requires a valid JWT session. The session is generated by the `/signin/auth/login` route and consists of a JWT token that encapsulates user information.

If the request does not contain a valid token, the server will return **error 403**.

To authenticate, send the token in the header:

```
Authorization: Bearer [TOKEN]
```

### `@HttpMethod`

Defines the allowed HTTP methods for the route:

```php
@HttpMethod("POST")
```

Supported methods:

- **POST**
- **GET**
- **OPTIONS**
- **PUT**
- **DELETE**


